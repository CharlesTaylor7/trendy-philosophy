{"version":3,"sources":["philPapers/streams.js","components/Graph.js","philPapers/usePhilPapers.js","serviceWorker.js","index.js","App.js"],"names":["xml","parser","escapeCharacter","char","getLastPartOfPath","path","match","_wrapRegExp","key","groups","record$","recordSet$","token","fromFetch","concat","split","map","join","escape","pipe","Rx","response","text","_xml$parse$OAIPMH$Li","parse","ListRecords","records","record","resumptionToken","Observable","metadata","_i","_Object$entries","Object","entries","length","_ref3","_ref2","slicedToArray","value","prop","title","String","id","identifier","year","date","type","subject","console","log","JSON","stringify","language","json","array","Graph","_ref","query","yearRange","_yearRange","start","end","_usePhilPapers","_useState","useState","stemsToRecords","yearsToRecords","_useState2","state","setState","useEffect","subscribe","blackList","words","R","stem","updatedRecords","objectSpread","defineProperty","stems","_iteratorNormalCompletion","_didIteratorError","_iteratorError","undefined","_step","_iterator","Symbol","iterator","next","done","word","toConsumableArray","err","return","years","usePhilPapers","recordIds","data","_ref4","_ref5","percentage","dataPoint","amt","react_default","a","createElement","es6","width","height","dataKey","stroke","label","Graph_Label","getTotal","Label","_ref6","x","y","dy","fill","fontSize","textAnchor","Boolean","window","location","hostname","ReactDOM","render","className","Graph_Graph","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.e68c76bd.chunk.js","sourcesContent":["import parser from 'fast-xml-parser';\r\nimport { fromFetch } from 'rxjs/fetch';\r\nimport * as Rx from 'rxjs/operators';\r\nimport * as Observable from 'rxjs';\r\nimport * as R from 'ramda';\r\n\r\nconst xml = parser;\r\n\r\nconst escapeCharacter = char => {\r\n  switch (char) {\r\n    case '/': return '%2F';\r\n    case '?': return '%3F';\r\n    case '#': return '%23';\r\n    case '=': return '%3D';\r\n    case ':': return '%3A';\r\n    case ';': return '%3B';\r\n    case ' ': return '%20';\r\n    case '%': return '%25';\r\n    case '+': return '%2B';\r\n    default: return char;\r\n  }\r\n};\r\nconst escape = token => token.split().map(escapeCharacter).join();\r\n\r\nconst recordSet$ = (token) => fromFetch(\r\n  `https://cors-anywhere.herokuapp.com/https://philpapers.org/oai.pl?verb=ListRecords&metadataPrefix=oai_dc${token ? `&resumptionToken=${escape(token)}` : ''}`)\r\n  .pipe(\r\n    Rx.flatMap(response => response.text()),\r\n    Rx.flatMap(text => {\r\n      const {\r\n        record: records,\r\n        resumptionToken,\r\n      } = xml.parse(text)['OAI-PMH'].ListRecords;\r\n\r\n      // return records;\r\n      return Observable.concat(\r\n        Observable.from(records),\r\n        recordSet$(resumptionToken)\r\n      );\r\n    })\r\n  );\r\n\r\nconst getLastPartOfPath = path => path.match(/^.*\\/(?<key>.*)$/).groups.key;\r\nconst getPropName = dcPropName => dcPropName.match(/^dc:(?<prop>\\w+)$/).groups.prop;\r\n\r\nconst getRecordMetadata = record => {\r\n  const metadata = {};\r\n  for (const [key, value] of Object.entries(record.metadata['oai_dc:dc'])) {\r\n    const prop = getPropName(key);\r\n    metadata[prop] = value;\r\n  }\r\n\r\n  metadata.title = metadata.title ? String(metadata.title) : null;\r\n  metadata.id = getLastPartOfPath(metadata.identifier);\r\n  delete metadata.identifier;\r\n\r\n  metadata.year = metadata.date;\r\n  delete metadata.date;\r\n\r\n  metadata.type = getLastPartOfPath(metadata.type);\r\n\r\n  if (metadata.subject !== 'Philosophy'){\r\n    console.log(JSON.stringify(metadata));\r\n    debugger;\r\n  }\r\n  return metadata;\r\n}\r\n\r\nexport const record$ = recordSet$()\r\n  .pipe(\r\n    Rx.map(getRecordMetadata),\r\n    Rx.filter(record =>\r\n      record.language === 'en' &&\r\n      record.title &&\r\n      typeof record.year === 'number'\r\n    ),\r\n  );\r\n\r\n// ToDo: Figure out how to parse and decompress data from archive.\r\nconst getDoc = id => fromFetch(`https://philpapers.org/archive/${id}`);\r\n\r\nconst apiId = '904518';\r\nconst apiKey = '5KLo4qkvXNl4t8s5';\r\n\r\nexport const category$ = fromFetch(`https://philpapers.org/philpapers/raw/categories.json?apiId=${apiId}&apiKey=${apiKey}`)\r\n  .pipe(\r\n    Rx.flatMap(response => response.json()),\r\n    Rx.map(array => array[0])\r\n  );\r\n","import React, { PureComponent } from 'react';\nimport { usePhilPapers } from '../philPapers/usePhilPapers';\nimport {\n  LineChart,\n  XAxis,\n  YAxis,\n  Line,\n  Tooltip,\n} from 'recharts';\nimport * as R from 'ramda';\nimport stem from 'lancaster-stemmer';\n\nexport const Graph = ({query, yearRange}) => {\n  const [ start, end ] = yearRange;\n  const {\n    records,\n    stemsToRecords,\n    yearsToRecords,\n  } = usePhilPapers();\n\n  // const recordCount = Object.keys(records).length;\n  const recordIds = stemsToRecords[stem(query)];\n  const data = recordIds\n    ? R.pipe(\n        R.map(id => records[id]),\n        R.groupBy(R.prop('year')),\n        R.toPairs,\n        R.filter(([year, _]) => year >= start && year <= end),\n        R.map(([year, group]) => ({\n          year,\n          percentage: 100 * group.length / yearsToRecords[year].length,\n        })),\n        R.map(dataPoint => {\n          return { ...dataPoint, amt: dataPoint.percentage };\n        })\n      )(recordIds)\n    : [];\n\n  const getTotal = year => yearsToRecords[year]\n    ? yearsToRecords[year].length\n    : 0;\n\n  return (\n    <LineChart width={1200} height={500} data={data}>\n      <Tooltip />\n      <XAxis dataKey=\"year\"/>\n      <YAxis />\n      <Line type=\"linear\" dataKey=\"percentage\" stroke =\"#8484d8\" label={<Label getTotal={getTotal} />}/>\n    </LineChart>\n  );\n}\n\nconst Label = ({\n  x,\n  y,\n  stroke,\n  value,\n  getTotal,\n}) => (\n  <text\n    x={x}\n    y={y}\n    dy={-4}\n    fill={stroke}\n    fontSize={10}\n    textAnchor=\"middle\"\n  >\n    {value}({getTotal(value)})\n  </text>\n);\n","import { useState, useEffect } from 'react';\r\nimport { record$ } from './streams';\r\nimport * as R from 'ramda';\r\nimport stem from 'lancaster-stemmer';\r\n\r\nexport const usePhilPapers = () => {\r\n  // state: { lookup: { [stem: string]: RecordId[] }, recordCount: number }\r\n  // where RecordId = string\r\n  // a map from word stems to a list of records containing that stem.\r\n  // The frequency of a stem is size of its dictionary entry divided by the record count.\r\n  const [ state, setState ] = useState({\r\n    records: {},\r\n    stemsToRecords: {},\r\n    yearsToRecords: {},\r\n  });\r\n\r\n  useEffect(() => {\r\n    record$.subscribe(record => {\r\n      const blackList = /^([0-9]+|s|the|of|on|and|to|in|at|for)$/\r\n      const words = R.pipe(\r\n        R.prop('title'),\r\n        R.split(/[\\s,.\\-_'â€™]/),\r\n        R.map(stem),\r\n        R.filter(stem => !R.isEmpty(stem) && R.isEmpty(R.match(blackList, stem))),\r\n        R.uniq,\r\n      )(record);\r\n\r\n      setState(state => {\r\n        const { stemsToRecords, yearsToRecords, records } = state;\r\n\r\n        const updatedRecords = {...records, [record.id]: record};\r\n\r\n        const stems = { ...stemsToRecords };\r\n        for (const word of words) {\r\n          if (stems[word] === undefined) {\r\n            stems[word] = [record.id];\r\n          } else {\r\n            stems[word] = [...stems[word], record.id];\r\n          }\r\n        }\r\n\r\n        const years = { ...yearsToRecords };\r\n        const { year } = record;\r\n        if (years[year] === undefined) {\r\n          years[year] = [record.id];\r\n        } else {\r\n          years[year] = [...years[year], record.id];\r\n        }\r\n\r\n        return {\r\n          records: updatedRecords,\r\n          stemsToRecords: stems,\r\n          yearsToRecords: years,\r\n        };\r\n      });\r\n    });\r\n  }, []);\r\n\r\n  return state;\r\n};\r\n","// This optional code is used to register a service worker.\r\n// register() is not called by default.\r\n\r\n// This lets the app load faster on subsequent visits in production, and gives\r\n// it offline capabilities. However, it also means that developers (and users)\r\n// will only see deployed updates on subsequent visits to a page, after all the\r\n// existing tabs open on the page have been closed, since previously cached\r\n// resources are updated in the background.\r\n\r\n// To learn more about the benefits of this model and instructions on how to\r\n// opt-in, read https://bit.ly/CRA-PWA\r\n\r\nconst isLocalhost = Boolean(\r\n  window.location.hostname === 'localhost' ||\r\n    // [::1] is the IPv6 localhost address.\r\n    window.location.hostname === '[::1]' ||\r\n    // 127.0.0.1/8 is considered localhost for IPv4.\r\n    window.location.hostname.match(\r\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\r\n    )\r\n);\r\n\r\nexport function register(config) {\r\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\r\n    // The URL constructor is available in all browsers that support SW.\r\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\r\n    if (publicUrl.origin !== window.location.origin) {\r\n      // Our service worker won't work if PUBLIC_URL is on a different origin\r\n      // from what our page is served on. This might happen if a CDN is used to\r\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\r\n      return;\r\n    }\r\n\r\n    window.addEventListener('load', () => {\r\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\r\n\r\n      if (isLocalhost) {\r\n        // This is running on localhost. Let's check if a service worker still exists or not.\r\n        checkValidServiceWorker(swUrl, config);\r\n\r\n        // Add some additional logging to localhost, pointing developers to the\r\n        // service worker/PWA documentation.\r\n        navigator.serviceWorker.ready.then(() => {\r\n          console.log(\r\n            'This web app is being served cache-first by a service ' +\r\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\r\n          );\r\n        });\r\n      } else {\r\n        // Is not localhost. Just register service worker\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    });\r\n  }\r\n}\r\n\r\nfunction registerValidSW(swUrl, config) {\r\n  navigator.serviceWorker\r\n    .register(swUrl)\r\n    .then(registration => {\r\n      registration.onupdatefound = () => {\r\n        const installingWorker = registration.installing;\r\n        if (installingWorker == null) {\r\n          return;\r\n        }\r\n        installingWorker.onstatechange = () => {\r\n          if (installingWorker.state === 'installed') {\r\n            if (navigator.serviceWorker.controller) {\r\n              // At this point, the updated precached content has been fetched,\r\n              // but the previous service worker will still serve the older\r\n              // content until all client tabs are closed.\r\n              console.log(\r\n                'New content is available and will be used when all ' +\r\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\r\n              );\r\n\r\n              // Execute callback\r\n              if (config && config.onUpdate) {\r\n                config.onUpdate(registration);\r\n              }\r\n            } else {\r\n              // At this point, everything has been precached.\r\n              // It's the perfect time to display a\r\n              // \"Content is cached for offline use.\" message.\r\n              console.log('Content is cached for offline use.');\r\n\r\n              // Execute callback\r\n              if (config && config.onSuccess) {\r\n                config.onSuccess(registration);\r\n              }\r\n            }\r\n          }\r\n        };\r\n      };\r\n    })\r\n    .catch(error => {\r\n      console.error('Error during service worker registration:', error);\r\n    });\r\n}\r\n\r\nfunction checkValidServiceWorker(swUrl, config) {\r\n  // Check if the service worker can be found. If it can't reload the page.\r\n  fetch(swUrl)\r\n    .then(response => {\r\n      // Ensure service worker exists, and that we really are getting a JS file.\r\n      const contentType = response.headers.get('content-type');\r\n      if (\r\n        response.status === 404 ||\r\n        (contentType != null && contentType.indexOf('javascript') === -1)\r\n      ) {\r\n        // No service worker found. Probably a different app. Reload the page.\r\n        navigator.serviceWorker.ready.then(registration => {\r\n          registration.unregister().then(() => {\r\n            window.location.reload();\r\n          });\r\n        });\r\n      } else {\r\n        // Service worker found. Proceed as normal.\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    })\r\n    .catch(() => {\r\n      console.log(\r\n        'No internet connection found. App is running in offline mode.'\r\n      );\r\n    });\r\n}\r\n\r\nexport function unregister() {\r\n  if ('serviceWorker' in navigator) {\r\n    navigator.serviceWorker.ready.then(registration => {\r\n      registration.unregister();\r\n    });\r\n  }\r\n}\r\n","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport './index.css';\r\nimport { App } from './App';\r\nimport * as serviceWorker from './serviceWorker';\r\n\r\nReactDOM.render(<App />, document.getElementById('root'));\r\n\r\n// If you want your app to work offline and load faster, you can change\r\n// unregister() to register() below. Note this comes with some pitfalls.\r\n// Learn more about service workers: https://bit.ly/CRA-PWA\r\nserviceWorker.unregister();\r\n","import React from 'react';\r\nimport './App.css';\r\nimport { Graph } from './components/Graph';\r\n\r\nexport const App = () => {\r\n  const query = 'good';\r\n  return (\r\n    <div className=\"App\">\r\n      <header className=\"App-header\">\r\n        <p>Trending: \"{query}\"</p>\r\n        <Graph query={query} yearRange={[2000, 2018]}/>\r\n      </header>\r\n    </div>\r\n  );\r\n}\r\n"],"sourceRoot":""}